using UnityEngine;

public class BallController : MonoBehaviour
{
    [Header("Jump Settings")]
    public float jumpDistance = 5f;
    public float jumpHeight = 3f;
    public float jumpDuration = 3f;

    [Header("Lane Settings")]
    public float laneOffset = 6f;
    private int currentLane = 1;

    private bool isJumping = false;

    // Swipe detection
    private Vector2 startTouchPos;
    
    // private float swipeThreshold = 50f;

    private void Update()
    {
        // HandleSwipeInput();
        HandleDragInput();

        if (!isJumping)
            StartCoroutine(PerformJump());
    }

    // void HandleSwipeInput()
    // {
    //     if (Input.touchCount > 0)
    //     {
    //         Touch t = Input.GetTouch(0);

    //         if (t.phase == TouchPhase.Began)
    //         {
    //             startTouchPos = t.position;
    //         }
    //         else if (t.phase == TouchPhase.Ended)
    //         {
    //             Vector2 endTouchPos = t.position;
    //             float dx = endTouchPos.x - startTouchPos.x;

    //             if (Mathf.Abs(dx) > swipeThreshold)
    //             {
    //                 if (dx > 0) ChangeLane(+1);   // Right swipe
    //                 else ChangeLane(-1);          // Left swipe
    //             }
    //         }
    //     }
    // }

    void HandleDragInput()
    {
        if (Input.touchCount > 0)
        {
            Touch t = Input.GetTouch(0);

            if (t.phase == TouchPhase.Began)
            {
                startTouchPos = t.position;
            }
            else if (t.phase == TouchPhase.Moved || t.phase == TouchPhase.Stationary)
            {
                float dx = t.position.x - startTouchPos.x;

                // How sensitive the drag is
                float dragSensitivity = 0.02f;

                // Convert drag distance to lane (-1, 0, +1)
                float normalizedX = dx * dragSensitivity;

                // Clamp to 3 lanes (0,1,2)
                if (normalizedX < -0.5f) currentLane = 0;
                else if (normalizedX > 0.5f) currentLane = 2;
                else currentLane = 1;
            }
        }
    }




    void ChangeLane(int direction)
    {
        currentLane = Mathf.Clamp(currentLane + direction, 0, 2);
    }

    System.Collections.IEnumerator PerformJump()
    {
        isJumping = true;

        Vector3 start = transform.position;

        float forward = start.z + jumpDistance;

        float targetX = (currentLane - 1) * laneOffset;

        Vector3 end = new Vector3(targetX, start.y, forward);

        float t = 0;

        while (t < 1)
        {
            t += Time.deltaTime / jumpDuration;

            // Jump arc (parabola)
            float height = 4f * jumpHeight * t * (1 - t);

            transform.position = Vector3.Lerp(start, end, t) + Vector3.up * height;

            yield return null;
        }

        transform.position = end;
        isJumping = false;
    }
}
